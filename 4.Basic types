// 4.1 Numbers


// 1.
// Remove something to make it work
fn main() {
    let x = 5; // <- Cut: ": i32"
    let mut y: u32 = 5;

    y = x;
    
    let z = 10; // Type of z ? 

    println!("Success!");
}

// 2.
// Fill the blank
fn main() {
    let v: u16 = 38_u8 as u16; // <- 8-бітове значення потрібно представити як 16-ти

    println!("Success!");
}

// 3.
// Modify `assert_eq!` to make it work
fn main() {
    let x = 5;
    assert_eq!("i32".to_string(), type_of(&x)); // <- u32 -> i32, так як x автоматично позначився як i32

    println!("Success!");
}

// Get the type of given variable, return a string representation of the type  , e.g "i8", "u8", "i32", "u32"
fn type_of<T>(_: &T) -> String {
    format!("{}", std::any::type_name::<T>())
}

// 4.
// Fill the blanks to make it work
fn main() {
    assert_eq!(i8::MAX, 127); 
    assert_eq!(u8::MAX, 255); 

    println!("Success!");
}

// 5.
// Fix errors and panics to make it work
fn main() {
   let v1 = 251_u16 + 8;
   let v2 = i16::checked_add(251, 8).unwrap(); // <- 8-бітні значення на 16-ти щрб держали числа більші за 255
   println!("{},{}",v1,v2);
}

// 6. 
// Modify `assert!` to make it work
fn main() {
    let v = 1_024 + 0xff + 0o77 + 0b1111_1111;
    assert!(v == 1597); // <- 9 і 7 помішені містами

    println!("Success!");
}

// 7.
// Fill the blank to make it work
fn main() {
    let x = 1_000.000_1; // ?
    let y: f32 = 0.12; // f32
    let z = 0.01_f64; // f64

    assert_eq!(type_of(&x), "f64".to_string()); // <- x автоматично позначений як f64
    println!("Success!");
}

fn type_of<T>(_: &T) -> String {
    format!("{}", std::any::type_name::<T>())
}

// 8.
// Make it work in two distinct ways
fn main() {
    assert!(0.1+0.2==0.3);

    println!("Success!");
}

// 1)
fn main() {
    // Check if the absolute difference is less than a tiny threshold
    assert!((0.1_f64 + 0.2_f64 - 0.3_f64).abs() < f64::EPSILON); // перевірка чи різниця менша ніж дуже мале значення EPSILON

    println!("Success!");
}

// 2)
fn main() {
    assert!((0.1 * 10.0 + 0.2 * 10.0) == (0.3 * 10.0)); // домножити обидві сторони на 10

    println!("Success!");
}

// 9.
// Two goals: 1. Modify assert! to make it work 2. Make println! output list of numbers between 97 and 122
fn main() {
    let mut sum = 0;
    for i in -3..2 {
        sum += i
    }

    assert!(sum == -5); // <- -3 -> -5 так як це сума діапазону -3..2

    for c in 'a'..='z' {
        println!("{}",c as u8); // <- c позначено як u8 для читання букв під ASCII нумерацією
    }
}

// 10.
// Fill the blanks
use std::ops::{Range, RangeInclusive};
fn main() {
    assert_eq!((1..5), Range{ start: 1, end: 5 });
    assert_eq!((1..=5), RangeInclusive::new(1, 5)); // <- додавляння = включає 5 в діапазон

    println!("Success!");
}

// 11.
